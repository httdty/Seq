//// Created by 44797 on 2019/11/17.//#include <iostrem>#define MaxValue 999typedef int ElemType;// 我的插入排序，这里没有使用哨兵节点void InsertSort_rth(ElemType A[], int n) {    int i, j;    for (i = 0; i < n; i++)        for (j = i - 1; j >= 0; j--) {            ElemType tmp = A[i];            if (A[j] > tmp) {                A[j + 1] = A[j];                A[j] = tmp;                break;            }        }}// 插入排序，使用哨兵节点，精妙，小心细节处的比较// 时间复杂度：最好O(n)，最坏O(n^2)// 空间复杂度：O(1)// 稳定void InsertSort(ElemType A[], int n) {    // @param: ElemType A[]：待排序数组，这里将第一个节点作为哨兵节点，数据存储于索引位1-n的位置上    // @param: int n: 排序元素个数（数组元素长度-1）    // @ret: void    int i, j;    for (i = 2; i <= n; i++) {        A[0] = A[i];  // 这里的A[0]是哨兵节点，用来保存当前遍历到的值        for (j = i - 1; A[j] > A[0]; i--)  // 直接在循环条件中比较大小，精妙，使用哨兵还能保证最后一个元素的判定            A[j + 1] = A[j];        A[j + 1] = A[0];  // 最后j又减了，记得加一    }}// 折半插入排序// 时间复杂度：最好O(n)，最坏O(n^2)// 空间复杂度：O(1)// 稳定void BInsertSort(ElemType A[], int n) {    int i, j;    int low, high, mid;    for (i = 2; i <= n; i++) {  // 折半查找部分，这里并不是真的想找到，只是确定high的位置        A[0] = A[i];        low = 1;        high = i - 1;        while (low <= high) {            mid = (low + high) / 2;            if (A[mid] > A[0])                high = mid - 1;            else                low = mid + 1;        }        for (j = i - 1; j >= high + 1; j--)  // 充分理解high+1的使用            A[j + 1] = A[j];        A[high + 1] = A[0];    }}// 希尔排序// 时间复杂度：O(n^2)（实际上是O(n^1.3)）// 空间复杂度：O(1)// 不稳定void ShellSort(ElemType A[], int n) {    for (int dk = n / 2; dk >= 1; dk /= 2) {        for (int i = dk + 1; i < n; i++) {  // 所有组同时实现            if (A[i] < A[i - 1]) {                A[0] = A[i];                for (int j = i - dk; j > 0 && A[0] < A[j]; j -= dk)                    A[j + dk] = A[j];                A[j + dk] = A[0];            }        }    }}// 冒泡排序// 时间复杂度：最好O(n)，最坏O(n^2)// 空间复杂度：O(1)// 稳定void BubbleSort(ElemType A[], int n) {    ElemType temp;    for (int i = 0; i < n - 1; i++) {        bool flag = false;        for (int j = n - 1; j > i; j--)            if (A[j - 1] > A[j]) {                temp = A[j - 1];                A[j - 1] = A[j];                A[j] = temp;                flag = true;            }        if (!flag)            return;    }}// 快速排序// 最好时间复杂度O(nlogn)// 最好平均空间复杂度O(logn)// 最坏的时间复杂度O(n^2)// 最坏的空间复杂度O(n)// 不稳定int Partition(ElemType A[], int low, int high) {    ElemType pivot = A[low];    while (low < high) {        while (low < high && A[high] >= pivot)            high--;        A[low] = A[high];        while (low < high && A[low] <= pivot)            low++;        A[high] = A[low];    }    A[low] = pivot;    return low;}void QuickSort(ElemType A[], int low, int high) {    if (low < high) {        int pivotpos = Partition(A, low, high);        QuickSort(A, low, pivotpos - 1);        QuickSort(A, pivotpos + 1, high);    }}// 选择排序// 时间复杂度O(n^2)，与初始序列无关// 空间复杂度O(1)// 顺序存储和链式存储// 不稳定void SelectSort(ElemType A[], int n) {    for (int i = 0; i < n - 1; i++) {  // 最后一个自动排好        int min = i;        for (int j = min + 1; j < n; j++)            if (A[j] < A[min])                min = j;        if (i != min) {            ElemType temp = A[min];            A[min] = A[i];            A[i] = temp;        }    }}// 堆排序// 时间复杂度：O(nlogn)// 空间复杂度：O(1)// 顺序存储、链式存储// 不稳定// 自顶向下调整void AdjustDown(ElemType A[], int k, int len) {    // @param: A[]，最大堆的存储，位于[1..len]，注意：A[0]中不存放有意义的值    // @param: k，待调整的位置    // @param: len，最大堆中的元素个数    A[0] = A[k];    for (int i = 2 * k; i <= len; i *= 2) {        if (i < len && A[i] < A[i + 1])            i++;        if (A[0] >= A[i])            break;        else {            A[k] = A[i];            k = i;        }    }    A[k] = A[0];}// 构建大根堆void BuildMaxHeap(ElemType A[], int len) {    for (int i = len / 2; i > 0; i--)  // 根节点的编号是1        AdjustDown(A, i, len);}// 堆排序void HeapSort(ElemType A[], int len) {    BuildMaxHeap(A, len);    for (int i = len; i > 1; i--) {        ElemType temp = A[1];        A[1] = A[i];        A[i] = temp;        AdjustDown(A, 1, i - 1)    }}// 自底向上调整（插入新节点）void AdjustUp(ElemType A[], int len) {    A[0] = A[len];    int i = k / 2;    while (i > 1 && A[i] < A[0]) {  // 和记录值作比较不会出错        A[k] = A[i];        k = i;        i /= 2;    }    A[k] = A[0];  // 最后赋值}// 归并排序// 时间复杂度O(nlogn)// 空间复杂度O(n)// 顺序存储、链式存储// 稳定// 合并操作，时间复杂度O(high-low+1)ElemType *B = (ElemType *)malloc((n + 1） * sizeof(ElemType)));void Merge(ElemType A[], int low, int mid, int high){    int i, j, k;    for (k = low; k <= high; k++){        B[k] = A[k];    }    for (i = low, j = mid + 1, k = low; i <= mid && j <= high; k++){        if (B[i] <= B[j])  // 达到稳定的关键            A[k] = B[i++];        else            A[k] = B[j++];    }    while (i <= mid)        A[k++] = B[i++];    while (j <= high)        A[k++] = B[j++];}void MergeSort(ElemType A[], int low, int high){    if (low < high) {        int mid = (high + low) / 2;        MergeSort(A, low, mid);        MergeSort(A, mid + 1, high);        Merge(A, low, mid, high);    }}